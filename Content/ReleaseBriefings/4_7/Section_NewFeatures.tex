%==========================================================================

\begin{frame}[fragile]

  {\Huge Feature highlights}

  \vspace{10pt}

\end{frame}

\begin{frame}[fragile]{MDSpan-based View Implementation}
  % what
  \begin{itemize}
    \item This release contains an extensive refactoring of \texttt{Kokkos::View}
    \item View was refactored to use the \texttt{mdspan}, a C++23 addition to the standard library
    \begin{itemize}
      \item \texttt{mdspan} is backported to C++17/C++20, and our implementation can be found at \url{github.com/kokkos/mdspan/}
    \end{itemize}
    \item The goal of this refactor was to provide better library interoperability, more API flexibility, and reduced maintenance burden
    \item In principle, this update should be fully transparent; i.e. your existing code should work as it did before and we've done extensive testing to ensure this
    \end{itemize}
% motivation
% example
% What does this mean for apps
\end{frame}

\begin{frame}[fragile]{MDSpan-based View Implementation}
  \begin{itemize}
  \item What does this mean for applications?
  \begin{itemize}
    \item We use the same customization points as mdspan now, including accessors and layout mappings
    \item This is also how we are working on support for Sacado with the new view implementation
    \begin{itemize}
      \item We don't have to special-case as much for Sacado inside of Kokkos anymore
      \item Full Sacado support coming in patch release
    \end{itemize}
    \item In the future, we may provide a mechanism for users to customize these. Would that be useful for people?
  \end{itemize}
  \end{itemize}
\end{frame}

%==========================================================================

% Examples

% note: always keep the [fragile] for your frames!

%\begin{frame}[fragile]{Example list}
%  \begin{itemize}
%      \item Item 1
%      \item Item 2 with some \texttt{code}
%      \begin{itemize}
%        \item Sub-item 2.1
%        \item Sub-item 2.2
%      \end{itemize}
%  \end{itemize}
%\end{frame}

%\begin{frame}[fragile]{Example code}
%    \begin{code}[keywords={std}]
%        #include <iostream>
%
%        int main() {
%            std::cout << "hello world\n";
%        }
%    \end{code}
%\end{frame}

%\begin{frame}[fragile]{Example table}
%    \begin{center}
%        \begin{tabular}{l|l}
%            a & b \\\hline
%            c & d
%        \end{tabular}
%    \end{center}
%\end{frame}

%==========================================================================



\begin{frame}[fragile]{Updates on Kokkos Graphs}
 \begin{itemize}
     \item Reminder: \emph{Kokkos Graph} is an abstraction of computation represented as a DAG
     \item Located in~\emph{Kokkos::Experimental}
      \item Example of a diamond-shaped compute graph supported
      \begin{code}[keywords={std}]
      auto graph = Kokkos::create_graph([&](auto root) {
      auto nodeA = root.then_parallel_for("workloadA",policy,functor);
      auto nodeB = nodeA.then_parallel_for("workloadB",policy,functor);
      auto nodeC = nodeA.then_parallel_for("workloadC",policy,functor);
      auto nodeD = Kokkos::when_all(nodeB, nodeC).
        then_parallel_for("workloadD",policy,functor);});
      graph.instantiate();
      graph.submit();
      \end{code}
     \item Restricted to Kokkos parallel patterns and device code
     \item We have two new features addressing this restriction
 \end{itemize}
\end{frame}


\begin{frame}[fragile]{Updates on Kokkos Graphs (Capture)}
 \begin{itemize}
     \item Add support for graph capture (Cuda, HIP and SYCL)
     \begin{itemize}
     \item Graph capture allows to add a graph node containing device code or call to a device library
  \end{itemize}
     \item Example: Capture of a cuBLAS call:
        \begin{code}[keywords={std}]
    auto graph = Kokkos::Experimental::create_graph([&](const auto& root){
      auto handle = create_cublas_handle();
       /* NEW! */
      root.cuda_capture(exec,
      [=](const Kokkos::Cuda& exec_){
        /* Body of lambda using CUDA */
        cublasSetStream(handle.get(),exec_.cuda_stream()));
        cublasDgemv( handle.get(),CUBLAS_OP_N,...);
      });
    });
    graph.instantiate(); 
    graph.submit(exec);
      \end{code}
    \item Supported backends: HIP, CUDA, SYCL (\emph{*\_capture})
 \end{itemize}
\end{frame}


\begin{frame}[fragile]{Updates on Kokkos Graphs (then\_host)}
 \begin{itemize}
     \item Add support for host-side graph nodes via the \emph{then\_host(...)} function
     \begin{itemize}
     \item Adding a host-node creates a new CPU execution node and adds it to the graph
     \item Registers a host-callback (and fences device exec space on execution)
  \end{itemize}
 \item Example: Using a host-side graph node
        \begin{code}[keywords={std}]
    class functor_d_t { };
    class functor_h_t { };
    ASSERT_EQ(counter.use_count(), 1);
      auto graph = Kokkos::Experimental::create_graph(exec, 
        [&](const auto& root) {
          root.then ("NodeA",exec,functor_d_t{)
          /* NEW!*/
          .then_host("NodeB",     functor_h_t{}) 
          .then     ("NodeC",exec,functor_d_t{});
      });      
      \end{code}
  \begin{itemize}
  \item Note:\emph{exec} can access host memory
  \item We explicitly use an execution policy with Kokkos::LaunchBounds<1> to execute a \emph{then} graph node
  \end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Updates on Kokkos Graphs (other)}
 \begin{itemize}
    \item Allow building Kokkos::Experimental::Graph object directly
    \begin{itemize}
    \item Allows default-constructed Kokkos::Experimental::Graph 
    \item Graph has a new \emph{root\_node()} public member function (returns the graph's root node)
    \item Example use:
     \begin{code}[keywords={std}]
      /* NEW! */
      Kokkos::Experimental::Graph graph{exec};
      graph.root_node().then_parallel_for(1, func{});
      graph.submit(exec);
        \end{code}
     \end{itemize}
 \end{itemize}
\end{frame}



