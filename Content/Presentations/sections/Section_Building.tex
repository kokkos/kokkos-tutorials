%!TEX root = ../modularized/KokkosTutorial_01_Introduction.tex
% \begin{frame}{DOE ECP Acknowledgement}

% \textit{
% This research was supported by the Exascale Computing Project (17-SC-20-SC),
% a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration,
% responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology,
% to support the nation’s exascale computing imperative. 
% }

% \end{frame}

%==============================================================================

\begin{frame}[fragile]


  \vspace{10pt}
  {\Huge Building Applications with Kokkos}

  \vspace{10pt}

  \textbf{Learning objectives:}
  \begin{itemize}
    \item{Integrate Kokkos into your project}
    \item{Build from source}
    \item{Package managers}
  \end{itemize}

%  \vspace{-20pt}
  \pause

  \begin{block}{Ignore This For Tutorial Only}
     The following details on options to integrate Kokkos into your build process are NOT necessary to know if you just want to do the tutorial.
  \end{block}

\end{frame}

\begin{frame}[fragile]{Options for Building Kokkos}

\begin{itemize}
\item \textbf{Install Kokkos and find it as extenal package:} For large projects with multiple dependencies installing Kokkos via CMake and then building against it is the best option.
\item \textbf{Build Kokkos embedded in your project:} This is an option suited for applications which have few dependencies (and no one depending on them) and want to build Kokkos inline with their application.
\item \textbf{Using Spack:} For projects which largely rely on components provided by the Spack package manager.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Kokkos CMake Basics}
\begin{itemize}
\item In the spirit of C++ for \emph{code} performance portability, modern CMake aims for \emph{build system} portability
\item Projects that depend on Kokkos should be agnostic to the exact build configuration of Kokkos
\item No CUDA details in C++! No CUDA details in CMake!
\item Kokkos provides a \texttt{Kokkos::kokkos} target.
  \begin{itemize}
  \item Include directories
  \item Link libraries
  \item Compiler options
  \item Etc
  \end{itemize}
 
\item Single command in your project should configure all compiler/linker flags:

\begin{shell}
add_library(myLib goTeamVenture.cpp)
target_link_libraries(myLib PUBLIC Kokkos::kokkos)
\end{shell}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{External Kokkos (recommended for most use cases)}

\begin{minted}[fontsize=\scriptsize]{cmake}
cmake_minimum_required(VERSION 3.22)
project(MyProject CXX)

find_package(Kokkos 4.2 REQUIRED CONFIG) # Find Kokkos version 4.2 or later

add_executable(HelloKokkos HelloKokkos.cpp)
target_link_libraries(HelloKokkos PRIVATE Kokkos::kokkos)
\end{minted}

\vspace{2eM}
\textbf{How do I control cmake's search procedure?}

\vspace{1eM}
\begin{minted}[fontsize=\scriptsize]{bash}
cmake -DKokkos_ROOT=/path/to/kokkos
\end{minted}
\end{frame}

\begin{frame}[fragile]
\frametitle{Embedded Kokkos}

\textbf{Option 1: via Git Submodules and \mintinline{cmake}{add_subdirectory()}}
\begin{minted}[fontsize=\scriptsize]{bash}
git submodule add -b 4.5.01 https://github.com/kokkos/kokkos.git tpls/kokkos
git commit -m 'Adding Kokkos v4.5.1 as a submodule'
\end{minted}
\begin{minted}[fontsize=\scriptsize]{cmake}
add_subdirectory(tpls/kokkos)
target_link_libraries(MyTarget PRIVATE Kokkos::kokkos)
\end{minted}

\vspace{2eM}

\textbf{Option 2: via \texttt{FetchContent}}
\begin{minted}[fontsize=\tiny]{cmake}
include(FetchContent)
FetchContent_Declare(
    Kokkos
    URL      https://github.com/kokkos/kokkos/releases/download/4.5.01/kokkos-4.5.01.tar.gz
    URL_HASH SHA256=52d003ffbbe05f30c89966e4009c017efb1662b02b2b73190670d3418719564c
)
FetchContent_MakeAvailable(Kokkos)
target_link_libraries(MyTarget PRIVATE Kokkos::kokkos)
\end{minted}
\end{frame}

\begin{frame}[fragile]
\frametitle{Supporting Both External and Embedded Kokkos}

\begin{minted}[fontsize=\scriptsize]{cmake}
find_package(Kokkos CONFIG) # Try to find Kokkos externally
if(Kokkos_FOUND)
    message(STATUS "Found external Kokkos")
else()
    message(STATUS "Kokkos not found. Using embedded Kokkos.")
    # or FetchContent if you prefer
    add_subdirectory(tpls/kokkos)
endif()
target_link_libraries(MyTarget PRIVATE Kokkos::kokkos)
\end{minted}

\pause

\vspace{1eM}
\textbf{How do I control the Kokkos integration?}

\pause

\vspace{1eM}
\textbf{External}
\begin{minted}[fontsize=\scriptsize]{bash}
cmake -DCMAKE_REQUIRE_FIND_PACKAGE_Kokkos=ON -DKokkos_ROOT=/path/to/kokkos
\end{minted}

\vspace{1eM}
\textbf{Embedded}
\begin{minted}[fontsize=\scriptsize]{bash}
cmake -DCMAKE_DISABLE_FIND_PACKAGE_Kokkos=ON
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Kokkos package introspection (advanced)}

Assert that the (experimental) relaxed constexpr support is enabled
% eensure that calling \texttt{\_\_device\_\_ constexpr} functions from a host function and \texttt{\_\_host\_\_ constexpr} funtions from a device function is allowed.
\begin{minted}[fontsize=\scriptsize]{cmake}
if(Kokkos_ENABLE_CUDA)
    kokkos_check(OPTIONS CUDA_CONSTEXPR)
    # fatal error if not enabled
endif()
\end{minted}

\vspace{1eM}
Query whether generation of relocatable device code is enabled
\begin{minted}[fontsize=\scriptsize]{cmake}
kokkos_check(
    OPTIONS CUDA_RELOCATABLE_DEVICE_CODE
    RESULT_VARIABLE KOKKOS_HAS_CUDA_RDC
)
if(NOT KOKKOS_HAS_CUDA_RDC)
    # ...
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Building Kokkos from source}
\textbf{Getting the Kokkos Source Code}

\scriptsize

\vspace{1eM}
\textbf{Option 1: Downloading a Release Archive (Recommended)}

Go to the \href{https://github.com/kokkos/kokkos/releases}{Kokkos releases} page and find the latest release (or a specific version you need).
\begin{minted}[fontsize=\tiny]{bash}
curl -sLO https://github.com/kokkos/kokkos/releases/download/4.6.01/kokkos-4.6.01.tar.gz
curl -sLO https://github.com/kokkos/kokkos/releases/download/4.6.01/kokkos-4.6.01-SHA-256.txt
grep kokkos-4.6.01.tar.gz kokkos-4.6.01-SHA-256.txt | shasum -c
# the output should be "kokkos-4.6.01.tar.gz: OK" or similar
# if the checksum doesn’t match, do not use the archive
tar -xzvf kokkos-4.6.01.tar.gz
\end{minted}

\vspace{1eM}
\textbf{Option 2: Cloning the Git Repository (For Development Versions)}

If you need the latest features or want to contribute to Kokkos, you can clone the Git repository.
\begin{minted}[fontsize=\scriptsize]{bash}
git clone https://github.com/kokkos/kokkos.git
cd kokkos
# checkout a release tag
git checkout 4.6.01
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Building Kokkos from source}
\textbf{Configuring Kokkos}

\begin{minted}[fontsize=\scriptsize]{bash}
cmake -B builddir [<options...>]
\end{minted}

\scriptsize
\textbf{Common CMake options:}
\begin{itemize}
\item \mintinline{bash}{-DCMAKE_CXX_COMPILER=<compiler>} for example \texttt{hipcc} for AMD GPUs, \texttt{icpx} for Intel GPUs, \texttt{nvcc\_wrapper} for NVIDIA GPUs
\item \mintinline{bash}{-DCMAKE_CXX_STANDARD=<standard>} default is \texttt{17} for Kokkos 4.X, \texttt{20} in 5.0
\item \mintinline{bash}{-DCMAKE_BUILD_TYPE=<type>} choose from \texttt{Debug}, \texttt{Release}, \texttt{RelWithDebInfo} (default), and \texttt{MinSizeRel}
\item \mintinline{bash}{-DCMAKE_INSTALL_PREFIX=<prefix>}
\end{itemize}

\textbf{Important Kokkos-specific options:}
\begin{itemize}
\item \mintinline{bash}{-DKokkos_ENABLE_<BACKEND>=ON}
\item \mintinline{bash}{-DKokkos_ARCH_<ARCHITECTURE>=ON}
\item \mintinline{bash}{-DKokkos_ENABLE_DEPRECATED_CODE_4=ON}
\item \mintinline{bash}{-DKokkos_ENABLE_DEPRECATION_WARNINGS=ON}
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Building Kokkos from source}

\scriptsize

\textbf{Refer to \url{https://kokkos.org} $>$Documentation$>$Get Started$>$Configuration Guide}


\vspace{1eM}
\textbf{Backends}
\begin{itemize}
\item You can only enable one "device" backend at a time (e.g., \texttt{CUDA}, \texttt{HIP}, or \texttt{SYCL})
\item Only one "host parallel" backend at a time (e.g., \texttt{OPENMP} or \texttt{THREADS})
\item A host backend is always required
\item If no host backend is explicitly enabled, the \texttt{SERIAL} backend will be used.
\end{itemize}

\begin{shell}[linebackground={
  \btLstHL{4}{orange!30},},
  basicstyle=\tiny\ttfamily,]
-- The project name is: Kokkos
...
-- Execution Spaces:
--     Device Parallel: CUDA
--     Host Parallel: NONE
--       Host Serial: SERIAL
\end{shell}

\textbf{Architectures}
\begin{itemize}
\item Device architecture is required, Kokkos will try to autodetect it at configuration time if you don't specify anything
\item Host architecture is optional, none by default, you may be able to use \mintinline{bash}{-DKokkos_ARCH_NATIVE=ON}
\end{itemize}
\begin{shell}[linebackground={
  \btLstHL{4}{orange!30},},
  basicstyle=\tiny\ttfamily,]
-- The project name is: Kokkos
...
-- Architectures:
--  HOPPER90
\end{shell}

\end{frame}

\begin{frame}[fragile]
\frametitle{Building Kokkos from source}
\textbf{Build}

After configuring, build Kokkos using:
\begin{minted}[fontsize=\footnotesize]{bash}
cmake --build builddir [-j<N>]
\end{minted}

This compiles Kokkos. You can add \texttt{-j<N>} to use multiple cores for faster compilation (replace \texttt{<N>} with the number of cores).

\vspace{1eM}
\textbf{Install}

To install Kokkos (header files and libraries), use:
\begin{minted}[fontsize=\footnotesize]{bash}
cmake --install builddir [--prefix <prefix>]
\end{minted}

The \texttt{--prefix <prefix>} option specifies the installation directory. If omitted, Kokkos will be installed to a default location, often \texttt{/usr/local} (not recommended).

\end{frame}


\begin{frame}[fragile]{Kokkos via Spack: Command Line}
\begin{itemize}
\item Spack provides a package manager that automatically downloads, configures, and installs package dependencies
\item Kokkos itself can be easily installed with specific variants (+) and compilers (\%)
\begin{shell}
spack install kokkos@develop +openmp %gcc@8.3.0
\end{shell}
\item Good practice is to define ``best variant`` in your packages.yaml directory, e.g. for Volta system
\begin{shell}
packages:
   kokkos:
    variants: +cuda +openmp \
              ^cuda@12.0 cuda_arch=70
    compiler: [gcc@8.3.0]
\end{shell}
\item Build rules in \inlineshell{package.py} automatically map Spack variants to correct CMake options
\item Run \inlineshell{spack info kokkos} to see full list of variants
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Kokkos via Spack: Package Files}
\begin{itemize}
\item Build rules created in a \inlineshell{package.py} file
\item Step 1: Declare dependency on specific version of kokkos (4.x or develop)
\begin{shell}
class myLib(CMakePackage):
  depends_on('kokkos@4.2')
\end{shell}
\item Step 2: Add build rule pointing to Spack-installed Kokkos and same C++ compiler Kokkos uses
\begin{shell}
def cmake_args(self):
  options = []
  ...
  options.append('-DCMAKE_CXX_COMPILER={}'.format(
      self['kokkos'].kokkos_cxx)
  return options
\end{shell}
\item More details on \url{https://kokkos.org} $>$Documentation$>$Get Started$>$Package Managers$>$Spack
\end{itemize}
\end{frame}

\begin{frame}{Section Summary}

  \begin{itemize}
    \item{Kokkos' primary build system is CMAKE.}
    \item{Kokkos options are transitively passed on, including many necessary compiler options.}
    \item{The Spack package manager does support Kokkos.}
    \item{If you write an application, and have few if any dependencies, building Kokkos as part of your code is an option.}
  \end{itemize}

\end{frame}
